/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pComponents.circularSlider;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.Toolkit;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import static java.lang.Math.PI;

/**
 *
 * @author Think
 */
public class CustomSlider extends javax.swing.JPanel implements MouseListener, MouseMotionListener  {

    /**
     * Creates new form CustomSlider
     */
    private static final int radius = 85;
    private static final int spotRadius = 10;
    private double theta;
    private double angle;
    private Color knobColor;
    private Color spotColor;
    private boolean pressedOnSpot;
    private Image image;
    private String imageURL = "./images/Pt_Cardinaux_150.png";
    
    //Constructeur
    public CustomSlider() {
        initComponents();
        theta = 0;
        angle = theta*180/PI;
	pressedOnSpot = false;
 	knobColor = Color.gray;
	spotColor = Color.black;

	this.addMouseListener((MouseListener) this);	
	this.addMouseMotionListener((MouseMotionListener) this);
    }

    

    //Getter & Setter
    public double getAngle() {
        return angle;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings(value = "unchecked")

    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    
 


    /**
     * No-Arg constructor that initializes the position
     * of the knob to 0 radians (Up).
     */
    /*
    public JKnob() {
	this(0);
    }
*/
    /**
     * Constructor that initializes the position
     * of the knob to the specified angle in radians.
     *
     * @param initAngle the initial angle of the knob.
     */
    /*
    public JKnob(double initTheta) {
	this(initTheta, Color.gray, Color.black);
    }*/
    
    /**
     * Constructor that initializes the position of the
     * knob to the specified position and also allows the
     * colors of the knob and spot to be specified.
     *
     * @param initAngle the initial angle of the knob.
     * @param initColor the color of the knob.
     * @param initSpotColor the color of the spot.
     */
    

    /**
     * Paint the JKnob on the graphics context given.  The knob
     * is a filled circle with a small filled circle offset 
     * within it to show the current angular position of the 
     * knob.
     *
     * @param g The graphics context on which to paint the knob.
     */
    public void paint(Graphics g) {
        super.paint(g);         //reset le paint et eviteque le point oval reste sur le panel et trace un cercle
	// Draw the knob.
        image = Toolkit.getDefaultToolkit().getImage(imageURL);
        g.drawImage(image, 8, 10, this);
	

	// Find the center of the spot.
	Point pt = getSpotCenter();
	int xc = (int)pt.getX();
	int yc = (int)pt.getY();

	// Draw the spot.
	g.setColor(spotColor);
	g.fillOval(xc-spotRadius, yc-spotRadius, 2*spotRadius, 2*spotRadius);
    }

    /**
     * Return the ideal size that the knob would like to be.
     *
     * @return the preferred size of the JKnob.
     */
    public Dimension getPreferredSize() {
	return new Dimension(2*radius,2*radius);
    }

    /**
     * Return the minimum size that the knob would like to be.
     * This is the same size as the preferred size so the
     * knob will be of a fixed size.
     *
     * @return the minimum size of the JKnob.
     */
    public Dimension getMinimumSize() {
	return new Dimension(2*radius,2*radius);
    }

    /**
     * Get the current anglular position of the knob.
     *
     * @return the current anglular position of the knob.
     */


    /** 
     * Calculate the x, y coordinates of the center of the spot.
     *
     * @return a Point containing the x,y position of the center
     *         of the spot.
     */ 
    private Point getSpotCenter() {

	// Calculate the center point of the spot RELATIVE to the
	// center of the of the circle.

	int r = radius - spotRadius;

	int xcp = (int)(r * Math.sin(theta));
	int ycp = (int)(r * Math.cos(theta));

	// Adjust the center point of the spot so that it is offset
	// from the center of the circle.  This is necessary becasue
	// 0,0 is not actually the center of the circle, it is  the 
        // upper left corner of the component!
	int xc = radius + xcp;
	int yc = radius - ycp;

	// Create a new Point to return since we can't  
	// return 2 values!
	return new Point(xc,yc);
    }

    /**
     * Determine if the mouse click was on the spot or
     * not.  If it was return true, otherwise return 
     * false.
     *
     * @return true if x,y is on the spot and false if not.
     */
    private boolean isOnSpot(Point pt) {
	return (pt.distance(getSpotCenter()) < spotRadius);
    }

    // Methods from the MouseListener interface.

    /**
     * Empy method because nothing happens on a click.
     *
     * @param e reference to a MouseEvent object describing 
     *          the mouse click.
     */
    public void mouseClicked(MouseEvent e) {}

    /**
     * Empty method because nothing happens when the mouse
     * enters the Knob.
     *
     * @param e reference to a MouseEvent object describing
     *          the mouse entry.
     */
    public void mouseEntered(MouseEvent e) {}

    /**
     * Empty method because nothing happens when the mouse
     * exits the knob.
     *
     * @param e reference to a MouseEvent object describing
     *          the mouse exit.
     */
    public void mouseExited(MouseEvent e) {}

    /**
     * When the mouse button is pressed, the dragging of the
     * spot will be enabled if the button was pressed over
     * the spot.
     *
     * @param e reference to a MouseEvent object describing
     *          the mouse press.
     */
    public void mousePressed(MouseEvent e) {

	Point mouseLoc = e.getPoint();
	pressedOnSpot = isOnSpot(mouseLoc);
    }

    /**
     * When the button is released, the dragging of the spot
     * is disabled.
     *
     * @param e reference to a MouseEvent object describing
     *          the mouse release.
     */
    public void mouseReleased(MouseEvent e) {
	pressedOnSpot = false;
        int mx = e.getX();
        int my = e.getY();

        // Compute the x, y position of the mouse RELATIVE
        // to the center of the knob.
        int mxp = mx - radius;
        int myp = radius - my;

        // Compute the new angle of the knob from the
        // new x and y position of the mouse.  
        // Math.atan2(...) computes the angle at which
        // x,y lies from the positive y axis with cw rotations
        // being positive and ccw being negative.
        theta = Math.atan2(mxp, myp);
        if((0<=theta)&&(theta<=180)){
            angle = theta*180/PI;
        }
        else{
            angle = 360+theta*180/PI;
        }
        repaint();
    }
    
    // Methods from the MouseMotionListener interface.

    /**
     * Empty method because nothing happens when the mouse
     * is moved if it is not being dragged.
     *
     * @param e reference to a MouseEvent object describing
     *          the mouse move.
     */
    public void mouseMoved(MouseEvent e) {}

    /**
     * Compute the new angle for the spot and repaint the 
     * knob.  The new angle is computed based on the new
     * mouse position.
     *
     * @param e reference to a MouseEvent object describing
     *          the mouse drag.
     */
    public void mouseDragged(MouseEvent e) {
	if (true) {
            
	    int mx = e.getX();
	    int my = e.getY();

	    // Compute the x, y position of the mouse RELATIVE
	    // to the center of the knob.
	    int mxp = mx - radius;
	    int myp = radius - my;

	    // Compute the new angle of the knob from the
	    // new x and y position of the mouse.  
	    // Math.atan2(...) computes the angle at which
	    // x,y lies from the positive y axis with cw rotations
	    // being positive and ccw being negative.
	    theta = Math.atan2(mxp, myp);
	    repaint();
	}
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
